---
phase: 03-agent-api
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - dashboard/lib/process-manager.ts
  - dashboard/lib/config-loader.ts
autonomous: true

must_haves:
  truths:
    - "ProcessManager is a singleton that persists across API route invocations"
    - "spawnAgent spawns actual child processes using config from agents.json"
    - "stopAgent terminates processes with proper cleanup (SIGTERM then SIGKILL)"
    - "subscribeToOutput streams stdout/stderr via EventEmitter pattern"
    - "Process state survives API route cold starts via module-level singleton"
  artifacts:
    - path: "dashboard/lib/process-manager.ts"
      provides: "Singleton ProcessManager class with spawn/stop/status/subscribe"
      contains: "class ProcessManager"
    - path: "dashboard/lib/config-loader.ts"
      provides: "Centralized config loading with caching"
      contains: "loadAgentsConfig"
  key_links:
    - from: "dashboard/lib/process-manager.ts"
      to: "config/agents.json"
      via: "config-loader"
      pattern: "loadAgentsConfig"
    - from: "dashboard/lib/process-manager.ts"
      to: "child_process"
      via: "spawn"
      pattern: "spawn\\("
---

<objective>
Create a ProcessManager singleton service that spawns and manages actual CLI agent processes.

Purpose: Replace mock implementations with real process management. The ProcessManager will be the single source of truth for agent state, spawn child processes using commands from agents.json, capture stdout/stderr, and provide subscription mechanism for real-time output streaming.

Output: A working ProcessManager module that can spawn claude/gemini/codex CLI processes, track their state, and stream their output.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@config/agents.json
@dashboard/types/agent-api.ts
@dashboard/app/api/agents/route.ts
@dashboard/app/api/agents/[id]/start/route.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create config-loader utility</name>
  <files>dashboard/lib/config-loader.ts</files>
  <action>
Create a centralized config loader that caches the agents.json configuration. This prevents redundant file reads across API routes.

```typescript
import { readFile } from 'fs/promises';
import { join } from 'path';
import type { AgentsConfigFile } from '@/types/agent-api';

let cachedConfig: AgentsConfigFile | null = null;
let configLoadTime: number = 0;
const CONFIG_CACHE_TTL = 30000; // 30 seconds

export async function loadAgentsConfig(): Promise<AgentsConfigFile> {
  const now = Date.now();

  // Return cached config if still valid
  if (cachedConfig && (now - configLoadTime) < CONFIG_CACHE_TTL) {
    return cachedConfig;
  }

  // Try multiple paths (dashboard cwd vs root cwd)
  const paths = [
    join(process.cwd(), '..', 'config', 'agents.json'),
    join(process.cwd(), 'config', 'agents.json'),
    '/opt/agency-workspace/dashboard-daddy/config/agents.json', // Docker absolute fallback
  ];

  for (const configPath of paths) {
    try {
      const content = await readFile(configPath, 'utf-8');
      cachedConfig = JSON.parse(content) as AgentsConfigFile;
      configLoadTime = now;
      return cachedConfig;
    } catch {
      continue;
    }
  }

  throw new Error('Failed to load agents config from any known path');
}

export function invalidateConfigCache(): void {
  cachedConfig = null;
  configLoadTime = 0;
}

export function getAgentConfig(agentId: string): Promise<AgentsConfigFile['agents'][string] | null> {
  return loadAgentsConfig().then(config => config.agents[agentId] || null);
}
```

Why centralized loader:
- Eliminates duplicate config loading code in every route file
- Adds caching to reduce file system reads
- Single place to update if config location changes
  </action>
  <verify>
Check file exists and exports loadAgentsConfig, invalidateConfigCache, getAgentConfig
TypeScript compiles without errors
  </verify>
  <done>Config loader module created with caching and multiple path fallbacks</done>
</task>

<task type="auto">
  <name>Task 2: Create ProcessManager singleton</name>
  <files>dashboard/lib/process-manager.ts</files>
  <action>
Create the ProcessManager class as a module-level singleton. This is critical - in Next.js serverless/edge environment, module-level variables persist across route invocations within the same process lifecycle.

```typescript
import { spawn, ChildProcess } from 'child_process';
import { EventEmitter } from 'events';
import { loadAgentsConfig } from './config-loader';
import type { AgentStatus } from '@/types/agent-api';

// Output message type for streaming
export interface AgentOutputMessage {
  type: 'stdout' | 'stderr' | 'system' | 'exit';
  data: string;
  timestamp: string;
  level?: 'info' | 'warn' | 'error' | 'debug';
}

// Tracked process info
export interface TrackedProcess {
  process: ChildProcess;
  agentId: string;
  jobId: string;
  status: AgentStatus;
  startedAt: string;
  workingDirectory: string;
  outputBuffer: AgentOutputMessage[];
  eventEmitter: EventEmitter;
}

// Process manager singleton class
class ProcessManager {
  private processes: Map<string, TrackedProcess> = new Map();
  private static instance: ProcessManager;

  private constructor() {
    // Private constructor for singleton
  }

  static getInstance(): ProcessManager {
    if (!ProcessManager.instance) {
      ProcessManager.instance = new ProcessManager();
    }
    return ProcessManager.instance;
  }

  generateJobId(): string {
    return `job_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`;
  }

  async spawnAgent(
    agentId: string,
    options: {
      workingDirectory?: string;
      prompt?: string;
      environment?: Record<string, string>;
    } = {}
  ): Promise<{ success: boolean; jobId?: string; error?: string }> {
    // Check if already running
    const existing = this.processes.get(agentId);
    if (existing && ['running', 'starting'].includes(existing.status)) {
      return {
        success: false,
        error: `Agent ${agentId} is already ${existing.status}`,
        jobId: existing.jobId
      };
    }

    // Load config
    const config = await loadAgentsConfig();
    const agentConfig = config.agents[agentId];

    if (!agentConfig) {
      return { success: false, error: `Agent not found: ${agentId}` };
    }

    if (!agentConfig.enabled) {
      return { success: false, error: `Agent ${agentId} is disabled` };
    }

    const jobId = this.generateJobId();
    const workingDirectory = options.workingDirectory || process.cwd();
    const eventEmitter = new EventEmitter();

    // Build command args
    const args = [...agentConfig.args];
    if (options.prompt) {
      // Most CLI agents accept prompt as positional arg or via --prompt
      args.push(options.prompt);
    }

    // Prepare environment
    const env = {
      ...process.env,
      ...options.environment,
    };

    // Create tracked process record (status: starting)
    const tracked: TrackedProcess = {
      process: null as unknown as ChildProcess, // Will be set below
      agentId,
      jobId,
      status: 'starting',
      startedAt: new Date().toISOString(),
      workingDirectory,
      outputBuffer: [],
      eventEmitter,
    };

    try {
      // Spawn the process
      const childProcess = spawn(agentConfig.command, args, {
        cwd: workingDirectory,
        env,
        stdio: ['pipe', 'pipe', 'pipe'],
        shell: true, // Use shell for PATH resolution
      });

      tracked.process = childProcess;
      this.processes.set(agentId, tracked);

      // Emit system message
      this.emitMessage(agentId, {
        type: 'system',
        data: `Starting ${agentConfig.name} (${agentConfig.command} ${args.join(' ')})`,
        timestamp: new Date().toISOString(),
        level: 'info',
      });

      // Handle stdout
      childProcess.stdout?.on('data', (data: Buffer) => {
        const message: AgentOutputMessage = {
          type: 'stdout',
          data: data.toString(),
          timestamp: new Date().toISOString(),
          level: 'info',
        };
        this.emitMessage(agentId, message);
      });

      // Handle stderr
      childProcess.stderr?.on('data', (data: Buffer) => {
        const message: AgentOutputMessage = {
          type: 'stderr',
          data: data.toString(),
          timestamp: new Date().toISOString(),
          level: 'error',
        };
        this.emitMessage(agentId, message);
      });

      // Handle process start
      childProcess.on('spawn', () => {
        const proc = this.processes.get(agentId);
        if (proc) {
          proc.status = 'running';
          this.emitMessage(agentId, {
            type: 'system',
            data: `${agentConfig.name} started (PID: ${childProcess.pid})`,
            timestamp: new Date().toISOString(),
            level: 'info',
          });
        }
      });

      // Handle process exit
      childProcess.on('exit', (code, signal) => {
        const proc = this.processes.get(agentId);
        if (proc) {
          proc.status = 'stopped';
          this.emitMessage(agentId, {
            type: 'exit',
            data: `Process exited with code ${code}${signal ? ` (signal: ${signal})` : ''}`,
            timestamp: new Date().toISOString(),
            level: code === 0 ? 'info' : 'error',
          });
        }
      });

      // Handle errors
      childProcess.on('error', (err) => {
        const proc = this.processes.get(agentId);
        if (proc) {
          proc.status = 'error';
          this.emitMessage(agentId, {
            type: 'system',
            data: `Error: ${err.message}`,
            timestamp: new Date().toISOString(),
            level: 'error',
          });
        }
      });

      return { success: true, jobId };
    } catch (err) {
      tracked.status = 'error';
      return {
        success: false,
        error: err instanceof Error ? err.message : 'Failed to spawn process'
      };
    }
  }

  async stopAgent(
    agentId: string,
    options: { force?: boolean } = {}
  ): Promise<{ success: boolean; error?: string }> {
    const tracked = this.processes.get(agentId);

    if (!tracked) {
      return { success: false, error: `No running process for agent: ${agentId}` };
    }

    if (tracked.status === 'stopped') {
      return { success: false, error: `Agent ${agentId} is already stopped` };
    }

    if (tracked.status === 'stopping') {
      return { success: false, error: `Agent ${agentId} is already stopping` };
    }

    tracked.status = 'stopping';

    this.emitMessage(agentId, {
      type: 'system',
      data: options.force ? 'Force stopping agent...' : 'Stopping agent gracefully...',
      timestamp: new Date().toISOString(),
      level: 'info',
    });

    try {
      const process = tracked.process;

      if (options.force) {
        // Force kill immediately
        process.kill('SIGKILL');
      } else {
        // Graceful shutdown: SIGTERM, then SIGKILL after timeout
        process.kill('SIGTERM');

        // Set timeout for force kill if process doesn't exit
        setTimeout(() => {
          if (tracked.status !== 'stopped') {
            process.kill('SIGKILL');
          }
        }, 5000);
      }

      return { success: true };
    } catch (err) {
      return {
        success: false,
        error: err instanceof Error ? err.message : 'Failed to stop process'
      };
    }
  }

  getAgentStatus(agentId: string): {
    status: AgentStatus;
    jobId?: string;
    startedAt?: string;
    pid?: number;
  } {
    const tracked = this.processes.get(agentId);

    if (!tracked) {
      return { status: 'stopped' };
    }

    return {
      status: tracked.status,
      jobId: tracked.jobId,
      startedAt: tracked.startedAt,
      pid: tracked.process?.pid,
    };
  }

  getAllStatuses(): Map<string, { status: AgentStatus; jobId?: string; startedAt?: string }> {
    const statuses = new Map();

    for (const [agentId, tracked] of this.processes) {
      statuses.set(agentId, {
        status: tracked.status,
        jobId: tracked.jobId,
        startedAt: tracked.startedAt,
      });
    }

    return statuses;
  }

  subscribeToOutput(
    agentId: string,
    callback: (message: AgentOutputMessage) => void
  ): () => void {
    const tracked = this.processes.get(agentId);

    if (!tracked) {
      // Return no-op unsubscribe
      return () => {};
    }

    // Send buffered messages first
    for (const message of tracked.outputBuffer) {
      callback(message);
    }

    // Subscribe to new messages
    tracked.eventEmitter.on('output', callback);

    // Return unsubscribe function
    return () => {
      tracked.eventEmitter.off('output', callback);
    };
  }

  getOutputBuffer(agentId: string, limit: number = 100): AgentOutputMessage[] {
    const tracked = this.processes.get(agentId);

    if (!tracked) {
      return [];
    }

    return tracked.outputBuffer.slice(-limit);
  }

  private emitMessage(agentId: string, message: AgentOutputMessage): void {
    const tracked = this.processes.get(agentId);

    if (!tracked) return;

    // Add to buffer (keep last 1000 messages)
    tracked.outputBuffer.push(message);
    if (tracked.outputBuffer.length > 1000) {
      tracked.outputBuffer = tracked.outputBuffer.slice(-1000);
    }

    // Emit to subscribers
    tracked.eventEmitter.emit('output', message);
  }

  // Send input to a running process stdin
  sendInput(agentId: string, input: string): boolean {
    const tracked = this.processes.get(agentId);

    if (!tracked || tracked.status !== 'running') {
      return false;
    }

    try {
      tracked.process.stdin?.write(input + '\n');
      return true;
    } catch {
      return false;
    }
  }
}

// Export singleton instance
export const processManager = ProcessManager.getInstance();

// Export convenience functions
export const spawnAgent = processManager.spawnAgent.bind(processManager);
export const stopAgent = processManager.stopAgent.bind(processManager);
export const getAgentStatus = processManager.getAgentStatus.bind(processManager);
export const getAllStatuses = processManager.getAllStatuses.bind(processManager);
export const subscribeToOutput = processManager.subscribeToOutput.bind(processManager);
export const getOutputBuffer = processManager.getOutputBuffer.bind(processManager);
export const sendInput = processManager.sendInput.bind(processManager);
```

Key design decisions:
1. **Singleton pattern** - Module-level instance persists in Node.js process memory
2. **EventEmitter for streaming** - Allows multiple SSE subscribers without polling
3. **Output buffer** - Stores last 1000 messages so late subscribers see history
4. **Graceful shutdown** - SIGTERM with 5s timeout before SIGKILL
5. **Shell mode** - Uses `shell: true` so PATH resolution works for claude/gemini/codex
  </action>
  <verify>
TypeScript compiles without errors
Run: `cd dashboard && npx tsc --noEmit lib/process-manager.ts lib/config-loader.ts`
ProcessManager exports all required functions
  </verify>
  <done>ProcessManager singleton created with spawn, stop, status tracking, and output streaming</done>
</task>

<task type="auto">
  <name>Task 3: Add types for process manager</name>
  <files>dashboard/types/agent-api.ts</files>
  <action>
Add additional types to support the ProcessManager. Append these to the existing types file:

```typescript
// Process management types (used by ProcessManager)
export interface SpawnAgentOptions {
  workingDirectory?: string;
  prompt?: string;
  environment?: Record<string, string>;
}

export interface SpawnAgentResult {
  success: boolean;
  jobId?: string;
  error?: string;
}

export interface StopAgentOptions {
  force?: boolean;
}

export interface StopAgentResult {
  success: boolean;
  error?: string;
}

export interface ProcessStatus {
  status: AgentStatus;
  jobId?: string;
  startedAt?: string;
  pid?: number;
}

export interface AgentOutputMessage {
  type: 'stdout' | 'stderr' | 'system' | 'exit';
  data: string;
  timestamp: string;
  level?: 'info' | 'warn' | 'error' | 'debug';
}
```

This ensures type safety between ProcessManager and API routes.
  </action>
  <verify>
Types compile without errors
No duplicate type definitions (AgentOutputMessage defined in process-manager should use this)
  </verify>
  <done>Process management types added to agent-api.ts</done>
</task>

<task type="auto">
  <name>Task 4: Test ProcessManager in isolation</name>
  <files></files>
  <action>
Verify ProcessManager works by running a simple test. Create a temporary test and run it:

```bash
cd dashboard

# Create a quick test script
cat > /tmp/test-process-manager.ts << 'EOF'
import { processManager } from './lib/process-manager';

async function test() {
  console.log('Testing ProcessManager...');

  // Test 1: Get status of non-existent agent
  const status1 = processManager.getAgentStatus('claude-code');
  console.log('Initial status:', status1);

  // Test 2: Spawn a simple echo command (mock agent for testing)
  // We'll spawn 'echo' instead of claude since claude may not be installed
  const result = await processManager.spawnAgent('test-agent', {
    workingDirectory: '/tmp',
    prompt: 'Hello World'
  });
  console.log('Spawn result:', result);

  // Test 3: Check status after spawn
  const status2 = processManager.getAgentStatus('test-agent');
  console.log('After spawn status:', status2);

  // Wait a moment for process to run
  await new Promise(r => setTimeout(r, 1000));

  // Test 4: Get output buffer
  const output = processManager.getOutputBuffer('test-agent');
  console.log('Output buffer:', output);

  console.log('Tests completed!');
}

test().catch(console.error);
EOF

# Run with ts-node or tsx
npx tsx /tmp/test-process-manager.ts
```

Note: This test may fail if the agent config doesn't have a 'test-agent' - that's expected. The key verification is that:
1. ProcessManager loads without errors
2. getAgentStatus returns { status: 'stopped' } for unknown agents
3. spawnAgent returns appropriate errors for missing config

For actual testing, we'll test with real API routes in Plan 03-02.
  </action>
  <verify>
ProcessManager module imports successfully
No runtime errors on import
TypeScript compiles the module
  </verify>
  <done>ProcessManager passes basic import and type checks</done>
</task>

</tasks>

<verification>
Plan 03-01 is complete when:
1. `dashboard/lib/config-loader.ts` exists and exports `loadAgentsConfig`
2. `dashboard/lib/process-manager.ts` exists and exports `processManager` singleton
3. ProcessManager has methods: spawnAgent, stopAgent, getAgentStatus, subscribeToOutput
4. Types compile: `cd dashboard && npx tsc --noEmit`
5. No duplicate agentStatusStore Maps remain in lib files
</verification>

<success_criteria>
- ProcessManager is a true singleton (same instance across imports)
- Uses child_process.spawn() with shell:true for PATH resolution
- Tracks process state: starting, running, stopping, stopped, error
- Captures stdout/stderr in real-time via EventEmitter
- Provides output buffer for late subscribers
- Graceful shutdown with SIGTERM -> timeout -> SIGKILL
- All types are exported and documented
</success_criteria>

<output>
After completion, create `.planning/phases/03-agent-api/03-01-SUMMARY.md` documenting:
- ProcessManager architecture decisions
- Event flow for output streaming
- Config loader caching strategy
- Known limitations (e.g., doesn't survive server restart)
</output>
