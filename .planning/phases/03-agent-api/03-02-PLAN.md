---
phase: 03-agent-api
plan: 02
type: execute
wave: 2
depends_on:
  - 03-01
files_modified:
  - dashboard/app/api/agents/route.ts
  - dashboard/app/api/agents/[id]/route.ts
  - dashboard/app/api/agents/[id]/start/route.ts
  - dashboard/app/api/agents/[id]/stop/route.ts
  - dashboard/app/api/agents/[id]/stream/route.ts
autonomous: true

must_haves:
  truths:
    - "POST /api/agents/[id]/start spawns actual child process via ProcessManager"
    - "POST /api/agents/[id]/stop terminates process with proper cleanup"
    - "GET /api/agents/[id]/stream pipes real process output via SSE"
    - "All routes use shared ProcessManager state (no duplicate Maps)"
    - "GET /api/agents returns real-time status from ProcessManager"
  artifacts:
    - path: "dashboard/app/api/agents/[id]/start/route.ts"
      provides: "Real process spawning via ProcessManager"
      contains: "spawnAgent"
    - path: "dashboard/app/api/agents/[id]/stop/route.ts"
      provides: "Real process termination via ProcessManager"
      contains: "stopAgent"
    - path: "dashboard/app/api/agents/[id]/stream/route.ts"
      provides: "Real output streaming from ProcessManager"
      contains: "subscribeToOutput"
  key_links:
    - from: "dashboard/app/api/agents/[id]/start/route.ts"
      to: "dashboard/lib/process-manager.ts"
      via: "import"
      pattern: "from.*process-manager"
    - from: "dashboard/app/api/agents/[id]/stream/route.ts"
      to: "dashboard/lib/process-manager.ts"
      via: "subscribeToOutput"
      pattern: "subscribeToOutput"
---

<objective>
Integrate the ProcessManager singleton with all agent API routes, replacing mock implementations with real process management.

Purpose: Connect the API layer to the ProcessManager service. After this plan, the API routes will spawn real CLI processes, track their actual state, and stream genuine output instead of mock data.

Output: Fully functional agent management API that can spawn/stop/monitor Claude, Gemini, and Codex CLI agents.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@dashboard/lib/process-manager.ts
@dashboard/lib/config-loader.ts
@dashboard/app/api/agents/route.ts
@dashboard/app/api/agents/[id]/start/route.ts
@dashboard/app/api/agents/[id]/stop/route.ts
@dashboard/app/api/agents/[id]/stream/route.ts
@dashboard/types/agent-api.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update main agents list route</name>
  <files>dashboard/app/api/agents/route.ts</files>
  <action>
Refactor the GET /api/agents route to use the centralized config-loader and ProcessManager for status. Remove the duplicate in-memory Map.

Replace the entire file with:

```typescript
import { NextResponse } from 'next/server';
import { loadAgentsConfig } from '@/lib/config-loader';
import { getAgentStatus } from '@/lib/process-manager';
import type {
  AgentWithStatus,
  AgentsListResponse,
  ApiErrorResponse,
} from '@/types/agent-api';

export async function GET(): Promise<NextResponse<AgentsListResponse | ApiErrorResponse>> {
  try {
    const config = await loadAgentsConfig();

    // Convert config agents to array with real-time status from ProcessManager
    const agents: AgentWithStatus[] = Object.entries(config.agents).map(([id, agent]) => {
      const statusInfo = getAgentStatus(id);

      return {
        id,
        name: agent.name,
        description: agent.description,
        enabled: agent.enabled,
        status: statusInfo.status,
        command: agent.command,
        args: agent.args,
        envRequired: agent.envRequired,
        features: agent.features,
        currentJobId: statusInfo.jobId,
        startedAt: statusInfo.startedAt,
        lastError: undefined, // TODO: Track errors in ProcessManager
      };
    });

    const response: AgentsListResponse = {
      agents,
      defaults: config.defaults,
      timestamp: new Date().toISOString(),
    };

    return NextResponse.json(response);
  } catch (error) {
    const errorResponse: ApiErrorResponse = {
      error: error instanceof Error ? error.message : 'Failed to load agents',
      code: 'AGENTS_LOAD_ERROR',
      timestamp: new Date().toISOString(),
    };

    return NextResponse.json(errorResponse, { status: 500 });
  }
}
```

Key changes:
- Removed the duplicate `agentStatusStore` Map (was lines 13-19)
- Removed `initializeAgentStatus`, `getAgentStatus`, `setAgentStatus` local functions
- Import `getAgentStatus` from ProcessManager instead
- Import `loadAgentsConfig` from centralized config-loader
- StatusInfo now comes from ProcessManager singleton (shared with other routes)
  </action>
  <verify>
grep "agentStatusStore" dashboard/app/api/agents/route.ts returns no matches
grep "from '@/lib/process-manager'" dashboard/app/api/agents/route.ts returns a match
grep "from '@/lib/config-loader'" dashboard/app/api/agents/route.ts returns a match
  </verify>
  <done>Main agents list route uses ProcessManager for real-time status</done>
</task>

<task type="auto">
  <name>Task 2: Update agent detail route</name>
  <files>dashboard/app/api/agents/[id]/route.ts</files>
  <action>
Refactor GET/PATCH /api/agents/[id] to use ProcessManager. Remove duplicate Map.

Replace the entire file with:

```typescript
import { NextRequest, NextResponse } from 'next/server';
import { loadAgentsConfig } from '@/lib/config-loader';
import { getAgentStatus, spawnAgent, stopAgent } from '@/lib/process-manager';
import type {
  AgentWithStatus,
  AgentDetailResponse,
  AgentUpdateRequest,
  AgentUpdateResponse,
  ApiErrorResponse,
} from '@/types/agent-api';

// GET /api/agents/[id] - Get single agent details
export async function GET(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
): Promise<NextResponse<AgentDetailResponse | ApiErrorResponse>> {
  try {
    const { id: agentId } = await params;

    if (!agentId) {
      const errorResponse: ApiErrorResponse = {
        error: 'Agent ID is required',
        code: 'INVALID_AGENT_ID',
        timestamp: new Date().toISOString(),
      };
      return NextResponse.json(errorResponse, { status: 400 });
    }

    const config = await loadAgentsConfig();
    const agentConfig = config.agents[agentId];

    if (!agentConfig) {
      const errorResponse: ApiErrorResponse = {
        error: `Agent not found: ${agentId}`,
        code: 'AGENT_NOT_FOUND',
        timestamp: new Date().toISOString(),
      };
      return NextResponse.json(errorResponse, { status: 404 });
    }

    const statusInfo = getAgentStatus(agentId);

    const agent: AgentWithStatus = {
      id: agentId,
      name: agentConfig.name,
      description: agentConfig.description,
      enabled: agentConfig.enabled,
      status: statusInfo.status,
      command: agentConfig.command,
      args: agentConfig.args,
      envRequired: agentConfig.envRequired,
      features: agentConfig.features,
      currentJobId: statusInfo.jobId,
      startedAt: statusInfo.startedAt,
      lastError: undefined,
    };

    const response: AgentDetailResponse = {
      agent,
      timestamp: new Date().toISOString(),
    };

    return NextResponse.json(response);
  } catch (error) {
    const errorResponse: ApiErrorResponse = {
      error: error instanceof Error ? error.message : 'Failed to get agent details',
      code: 'AGENT_FETCH_ERROR',
      timestamp: new Date().toISOString(),
    };
    return NextResponse.json(errorResponse, { status: 500 });
  }
}

// PATCH /api/agents/[id] - Update agent (start/stop)
export async function PATCH(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
): Promise<NextResponse<AgentUpdateResponse | ApiErrorResponse>> {
  try {
    const { id: agentId } = await params;

    if (!agentId) {
      const errorResponse: ApiErrorResponse = {
        error: 'Agent ID is required',
        code: 'INVALID_AGENT_ID',
        timestamp: new Date().toISOString(),
      };
      return NextResponse.json(errorResponse, { status: 400 });
    }

    const config = await loadAgentsConfig();
    const agentConfig = config.agents[agentId];

    if (!agentConfig) {
      const errorResponse: ApiErrorResponse = {
        error: `Agent not found: ${agentId}`,
        code: 'AGENT_NOT_FOUND',
        timestamp: new Date().toISOString(),
      };
      return NextResponse.json(errorResponse, { status: 404 });
    }

    // Parse request body
    let body: AgentUpdateRequest;
    try {
      body = await request.json();
    } catch {
      const errorResponse: ApiErrorResponse = {
        error: 'Invalid request body',
        code: 'INVALID_REQUEST_BODY',
        timestamp: new Date().toISOString(),
      };
      return NextResponse.json(errorResponse, { status: 400 });
    }

    if (!body.action || !['start', 'stop'].includes(body.action)) {
      const errorResponse: ApiErrorResponse = {
        error: 'Invalid action. Must be "start" or "stop"',
        code: 'INVALID_ACTION',
        timestamp: new Date().toISOString(),
      };
      return NextResponse.json(errorResponse, { status: 400 });
    }

    let message: string;

    if (body.action === 'start') {
      if (!agentConfig.enabled) {
        const errorResponse: ApiErrorResponse = {
          error: 'Cannot start disabled agent',
          code: 'AGENT_DISABLED',
          timestamp: new Date().toISOString(),
        };
        return NextResponse.json(errorResponse, { status: 400 });
      }

      const result = await spawnAgent(agentId);

      if (!result.success) {
        const errorResponse: ApiErrorResponse = {
          error: result.error || 'Failed to start agent',
          code: 'AGENT_START_FAILED',
          timestamp: new Date().toISOString(),
        };
        return NextResponse.json(errorResponse, { status: 409 });
      }

      message = `Agent ${agentConfig.name} started successfully`;
    } else {
      const result = await stopAgent(agentId);

      if (!result.success) {
        const errorResponse: ApiErrorResponse = {
          error: result.error || 'Failed to stop agent',
          code: 'AGENT_STOP_FAILED',
          timestamp: new Date().toISOString(),
        };
        return NextResponse.json(errorResponse, { status: 409 });
      }

      message = `Agent ${agentConfig.name} stopped successfully`;
    }

    // Get updated status after action
    const statusInfo = getAgentStatus(agentId);

    const agent: AgentWithStatus = {
      id: agentId,
      name: agentConfig.name,
      description: agentConfig.description,
      enabled: agentConfig.enabled,
      status: statusInfo.status,
      command: agentConfig.command,
      args: agentConfig.args,
      envRequired: agentConfig.envRequired,
      features: agentConfig.features,
      currentJobId: statusInfo.jobId,
      startedAt: statusInfo.startedAt,
      lastError: undefined,
    };

    const response: AgentUpdateResponse = {
      agent,
      message,
      timestamp: new Date().toISOString(),
    };

    return NextResponse.json(response);
  } catch (error) {
    const errorResponse: ApiErrorResponse = {
      error: error instanceof Error ? error.message : 'Failed to update agent',
      code: 'AGENT_UPDATE_ERROR',
      timestamp: new Date().toISOString(),
    };
    return NextResponse.json(errorResponse, { status: 500 });
  }
}
```

Key changes:
- Removed duplicate `agentStatusStore` Map
- Import functions from ProcessManager
- PATCH now calls real `spawnAgent` and `stopAgent`
- Status after action reflects real process state
  </action>
  <verify>
grep "agentStatusStore" dashboard/app/api/agents/[id]/route.ts returns no matches
grep "spawnAgent" dashboard/app/api/agents/[id]/route.ts returns a match
grep "stopAgent" dashboard/app/api/agents/[id]/route.ts returns a match
  </verify>
  <done>Agent detail route uses ProcessManager for real operations</done>
</task>

<task type="auto">
  <name>Task 3: Update start route with real process spawning</name>
  <files>dashboard/app/api/agents/[id]/start/route.ts</files>
  <action>
Refactor POST /api/agents/[id]/start to spawn real processes via ProcessManager.

Replace the entire file with:

```typescript
import { NextRequest, NextResponse } from 'next/server';
import { loadAgentsConfig } from '@/lib/config-loader';
import { spawnAgent, getAgentStatus } from '@/lib/process-manager';
import type {
  AgentStartRequest,
  AgentStartResponse,
  ApiErrorResponse,
} from '@/types/agent-api';

// POST /api/agents/[id]/start - Start an agent
export async function POST(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
): Promise<NextResponse<AgentStartResponse | ApiErrorResponse>> {
  try {
    const { id: agentId } = await params;

    if (!agentId) {
      const errorResponse: ApiErrorResponse = {
        error: 'Agent ID is required',
        code: 'INVALID_AGENT_ID',
        timestamp: new Date().toISOString(),
      };
      return NextResponse.json(errorResponse, { status: 400 });
    }

    const config = await loadAgentsConfig();
    const agentConfig = config.agents[agentId];

    if (!agentConfig) {
      const errorResponse: ApiErrorResponse = {
        error: `Agent not found: ${agentId}`,
        code: 'AGENT_NOT_FOUND',
        timestamp: new Date().toISOString(),
      };
      return NextResponse.json(errorResponse, { status: 404 });
    }

    if (!agentConfig.enabled) {
      const errorResponse: ApiErrorResponse = {
        error: 'Cannot start disabled agent',
        code: 'AGENT_DISABLED',
        timestamp: new Date().toISOString(),
      };
      return NextResponse.json(errorResponse, { status: 400 });
    }

    // Check current status
    const currentStatus = getAgentStatus(agentId);

    if (currentStatus.status === 'running') {
      const errorResponse: ApiErrorResponse = {
        error: 'Agent is already running',
        code: 'AGENT_ALREADY_RUNNING',
        details: {
          currentJobId: currentStatus.jobId,
          startedAt: currentStatus.startedAt,
        },
        timestamp: new Date().toISOString(),
      };
      return NextResponse.json(errorResponse, { status: 409 });
    }

    if (currentStatus.status === 'starting') {
      const errorResponse: ApiErrorResponse = {
        error: 'Agent is already starting',
        code: 'AGENT_STARTING',
        timestamp: new Date().toISOString(),
      };
      return NextResponse.json(errorResponse, { status: 409 });
    }

    // Parse optional request body for spawn options
    let startRequest: AgentStartRequest = {};
    try {
      const body = await request.text();
      if (body) {
        startRequest = JSON.parse(body);
      }
    } catch {
      // Body is optional, ignore parse errors
    }

    // Spawn the actual process via ProcessManager
    const result = await spawnAgent(agentId, {
      workingDirectory: startRequest.workingDirectory,
      prompt: startRequest.taskId, // Use taskId as the prompt for now
      environment: startRequest.environment,
    });

    if (!result.success) {
      const errorResponse: ApiErrorResponse = {
        error: result.error || 'Failed to start agent',
        code: 'AGENT_START_ERROR',
        timestamp: new Date().toISOString(),
      };
      return NextResponse.json(errorResponse, { status: 500 });
    }

    const response: AgentStartResponse = {
      success: true,
      jobId: result.jobId!,
      agentId,
      message: `Agent ${agentConfig.name} is starting`,
      timestamp: new Date().toISOString(),
    };

    // Log start request details (for debugging)
    if (startRequest.taskId) {
      console.log(`Starting agent ${agentId} with task: ${startRequest.taskId}`);
    }
    if (startRequest.workingDirectory) {
      console.log(`Working directory: ${startRequest.workingDirectory}`);
    }

    return NextResponse.json(response, { status: 202 }); // 202 Accepted
  } catch (error) {
    const errorResponse: ApiErrorResponse = {
      error: error instanceof Error ? error.message : 'Failed to start agent',
      code: 'AGENT_START_ERROR',
      timestamp: new Date().toISOString(),
    };
    return NextResponse.json(errorResponse, { status: 500 });
  }
}
```

Key changes:
- Removed duplicate `agentStatusStore` Map and helper functions
- Calls real `spawnAgent` from ProcessManager
- Passes workingDirectory and prompt options to spawnAgent
- Returns actual jobId from ProcessManager
- No more setTimeout mocks - real async process spawning
  </action>
  <verify>
grep "agentStatusStore" dashboard/app/api/agents/[id]/start/route.ts returns no matches
grep "setTimeout" dashboard/app/api/agents/[id]/start/route.ts returns no matches (mock removed)
grep "spawnAgent" dashboard/app/api/agents/[id]/start/route.ts returns matches
  </verify>
  <done>Start route spawns real processes via ProcessManager</done>
</task>

<task type="auto">
  <name>Task 4: Update stop route with real process termination</name>
  <files>dashboard/app/api/agents/[id]/stop/route.ts</files>
  <action>
Refactor POST /api/agents/[id]/stop to terminate real processes via ProcessManager.

Replace the entire file with:

```typescript
import { NextRequest, NextResponse } from 'next/server';
import { loadAgentsConfig } from '@/lib/config-loader';
import { stopAgent, getAgentStatus } from '@/lib/process-manager';
import type {
  AgentStopRequest,
  AgentStopResponse,
  ApiErrorResponse,
} from '@/types/agent-api';

// POST /api/agents/[id]/stop - Stop an agent
export async function POST(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
): Promise<NextResponse<AgentStopResponse | ApiErrorResponse>> {
  try {
    const { id: agentId } = await params;

    if (!agentId) {
      const errorResponse: ApiErrorResponse = {
        error: 'Agent ID is required',
        code: 'INVALID_AGENT_ID',
        timestamp: new Date().toISOString(),
      };
      return NextResponse.json(errorResponse, { status: 400 });
    }

    const config = await loadAgentsConfig();
    const agentConfig = config.agents[agentId];

    if (!agentConfig) {
      const errorResponse: ApiErrorResponse = {
        error: `Agent not found: ${agentId}`,
        code: 'AGENT_NOT_FOUND',
        timestamp: new Date().toISOString(),
      };
      return NextResponse.json(errorResponse, { status: 404 });
    }

    // Check current status
    const currentStatus = getAgentStatus(agentId);

    if (currentStatus.status === 'stopped') {
      const errorResponse: ApiErrorResponse = {
        error: 'Agent is already stopped',
        code: 'AGENT_ALREADY_STOPPED',
        timestamp: new Date().toISOString(),
      };
      return NextResponse.json(errorResponse, { status: 409 });
    }

    if (currentStatus.status === 'stopping') {
      const errorResponse: ApiErrorResponse = {
        error: 'Agent is already stopping',
        code: 'AGENT_STOPPING',
        timestamp: new Date().toISOString(),
      };
      return NextResponse.json(errorResponse, { status: 409 });
    }

    // Parse optional request body for stop options
    let stopRequest: AgentStopRequest = {};
    try {
      const body = await request.text();
      if (body) {
        stopRequest = JSON.parse(body);
      }
    } catch {
      // Body is optional, ignore parse errors
    }

    // Stop the actual process via ProcessManager
    const result = await stopAgent(agentId, {
      force: stopRequest.force,
    });

    if (!result.success) {
      const errorResponse: ApiErrorResponse = {
        error: result.error || 'Failed to stop agent',
        code: 'AGENT_STOP_ERROR',
        timestamp: new Date().toISOString(),
      };
      return NextResponse.json(errorResponse, { status: 500 });
    }

    const response: AgentStopResponse = {
      success: true,
      agentId,
      message: stopRequest.force
        ? `Agent ${agentConfig.name} is being force stopped`
        : `Agent ${agentConfig.name} is stopping gracefully`,
      timestamp: new Date().toISOString(),
    };

    return NextResponse.json(response, { status: 202 }); // 202 Accepted
  } catch (error) {
    const errorResponse: ApiErrorResponse = {
      error: error instanceof Error ? error.message : 'Failed to stop agent',
      code: 'AGENT_STOP_ERROR',
      timestamp: new Date().toISOString(),
    };
    return NextResponse.json(errorResponse, { status: 500 });
  }
}
```

Key changes:
- Removed duplicate `agentStatusStore` Map and helper functions
- Calls real `stopAgent` from ProcessManager
- Passes force option for SIGKILL vs SIGTERM
- No more setTimeout mocks - real process termination
  </action>
  <verify>
grep "agentStatusStore" dashboard/app/api/agents/[id]/stop/route.ts returns no matches
grep "setTimeout" dashboard/app/api/agents/[id]/stop/route.ts returns no matches (mock removed)
grep "stopAgent" dashboard/app/api/agents/[id]/stop/route.ts returns matches
  </verify>
  <done>Stop route terminates real processes via ProcessManager</done>
</task>

<task type="auto">
  <name>Task 5: Update stream route with real output streaming</name>
  <files>dashboard/app/api/agents/[id]/stream/route.ts</files>
  <action>
Refactor GET /api/agents/[id]/stream to pipe real process output via ProcessManager.

Replace the entire file with:

```typescript
import { NextRequest } from 'next/server';
import {
  subscribeToOutput,
  getOutputBuffer,
  getAgentStatus,
  sendInput,
} from '@/lib/process-manager';
import type { AgentOutputMessage } from '@/lib/process-manager';

// Format message as SSE event
function formatSSEMessage(message: AgentOutputMessage): string {
  const data = JSON.stringify(message);
  return `data: ${data}\n\n`;
}

// SSE response helper
function createSSEResponse(stream: ReadableStream): Response {
  return new Response(stream, {
    headers: {
      'Content-Type': 'text/event-stream',
      'Cache-Control': 'no-cache, no-transform',
      'Connection': 'keep-alive',
      'X-Accel-Buffering': 'no', // Disable nginx buffering
    },
  });
}

export async function GET(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
): Promise<Response> {
  const { id: agentId } = await params;

  // Validate agent ID
  if (!agentId || typeof agentId !== 'string') {
    return new Response(JSON.stringify({ error: 'Invalid agent ID' }), {
      status: 400,
      headers: { 'Content-Type': 'application/json' },
    });
  }

  // Check if agent has any state in ProcessManager
  const status = getAgentStatus(agentId);

  // Create a TransformStream for SSE
  const { readable, writable } = new TransformStream();
  const writer = writable.getWriter();
  const encoder = new TextEncoder();

  // Handle client disconnect
  const abortController = new AbortController();
  request.signal.addEventListener('abort', () => {
    abortController.abort();
  });

  // Start streaming in the background
  (async () => {
    try {
      // Send initial connection event with current status
      await writer.write(
        encoder.encode(
          `event: connected\ndata: ${JSON.stringify({
            status: 'connected',
            agentStatus: status.status,
            jobId: status.jobId,
          })}\n\n`
        )
      );

      // Send buffered output history first (last 100 messages)
      const bufferedOutput = getOutputBuffer(agentId, 100);
      for (const message of bufferedOutput) {
        if (abortController.signal.aborted) break;
        await writer.write(encoder.encode(formatSSEMessage(message)));
      }

      // If agent is not running, send a system message and keep connection for future output
      if (status.status === 'stopped') {
        await writer.write(
          encoder.encode(
            formatSSEMessage({
              type: 'system',
              data: `Agent ${agentId} is not running. Waiting for agent to start...`,
              timestamp: new Date().toISOString(),
              level: 'info',
            })
          )
        );
      }

      // Keep-alive ping every 30 seconds
      const pingInterval = setInterval(async () => {
        try {
          if (!abortController.signal.aborted) {
            await writer.write(encoder.encode(': ping\n\n'));
          } else {
            clearInterval(pingInterval);
          }
        } catch {
          clearInterval(pingInterval);
        }
      }, 30000);

      // Subscribe to real-time output from ProcessManager
      const unsubscribe = subscribeToOutput(agentId, async (message) => {
        if (abortController.signal.aborted) {
          unsubscribe();
          return;
        }

        try {
          await writer.write(encoder.encode(formatSSEMessage(message)));
        } catch {
          unsubscribe();
        }
      });

      // Wait for abort signal (client disconnect)
      await new Promise<void>((resolve) => {
        abortController.signal.addEventListener('abort', () => {
          resolve();
        });
      });

      // Cleanup
      clearInterval(pingInterval);
      unsubscribe();
    } catch (error) {
      // Send error event before closing
      const errorMessage: AgentOutputMessage = {
        type: 'system',
        data: error instanceof Error ? error.message : 'Unknown error',
        timestamp: new Date().toISOString(),
        level: 'error',
      };

      try {
        await writer.write(encoder.encode(formatSSEMessage(errorMessage)));
      } catch {
        // Writer may already be closed
      }
    } finally {
      try {
        await writer.close();
      } catch {
        // Writer may already be closed
      }
    }
  })();

  return createSSEResponse(readable);
}

// Handle POST for sending input to the agent
export async function POST(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
): Promise<Response> {
  const { id: agentId } = await params;

  try {
    const body = await request.json();
    const { command } = body;

    if (!command || typeof command !== 'string') {
      return new Response(JSON.stringify({ error: 'Invalid command' }), {
        status: 400,
        headers: { 'Content-Type': 'application/json' },
      });
    }

    // Send input to the actual running process
    const success = sendInput(agentId, command);

    if (!success) {
      return new Response(
        JSON.stringify({
          error: 'Failed to send input. Agent may not be running.',
          agentId,
        }),
        {
          status: 400,
          headers: { 'Content-Type': 'application/json' },
        }
      );
    }

    return new Response(
      JSON.stringify({
        success: true,
        agentId,
        command,
        timestamp: new Date().toISOString(),
      }),
      {
        status: 200,
        headers: { 'Content-Type': 'application/json' },
      }
    );
  } catch {
    return new Response(JSON.stringify({ error: 'Invalid request body' }), {
      status: 400,
      headers: { 'Content-Type': 'application/json' },
    });
  }
}
```

Key changes:
- Removed fake `generateAgentOutput` generator
- Uses `subscribeToOutput` to get real process output
- Sends buffered history on connect via `getOutputBuffer`
- Uses `sendInput` to write to process stdin
- Properly handles client disconnect with unsubscribe
- Works even when agent is stopped (waits for future output)
  </action>
  <verify>
grep "generateAgentOutput" dashboard/app/api/agents/[id]/stream/route.ts returns no matches (mock removed)
grep "subscribeToOutput" dashboard/app/api/agents/[id]/stream/route.ts returns matches
grep "getOutputBuffer" dashboard/app/api/agents/[id]/stream/route.ts returns matches
grep "sendInput" dashboard/app/api/agents/[id]/stream/route.ts returns matches
  </verify>
  <done>Stream route pipes real process output via ProcessManager</done>
</task>

<task type="auto">
  <name>Task 6: Verify no duplicate state stores remain</name>
  <files></files>
  <action>
Run a comprehensive grep to ensure no duplicate `agentStatusStore` Maps remain in any API route files:

```bash
cd /opt/agency-workspace/dashboard-daddy

# Check for any remaining agentStatusStore declarations
grep -r "agentStatusStore" dashboard/app/api/agents/

# Should return empty - all routes now use ProcessManager

# Verify all routes import from process-manager
grep -r "from '@/lib/process-manager'" dashboard/app/api/agents/

# Should show imports in:
# - dashboard/app/api/agents/route.ts
# - dashboard/app/api/agents/[id]/route.ts
# - dashboard/app/api/agents/[id]/start/route.ts
# - dashboard/app/api/agents/[id]/stop/route.ts
# - dashboard/app/api/agents/[id]/stream/route.ts

# Verify all routes import from config-loader
grep -r "from '@/lib/config-loader'" dashboard/app/api/agents/

# Should show imports in all routes except stream (doesn't need config)
```

This ensures there's a single source of truth for agent state.
  </action>
  <verify>
No files contain "agentStatusStore"
All API route files import from process-manager
TypeScript compiles without errors: cd dashboard && npx tsc --noEmit
  </verify>
  <done>All routes use shared ProcessManager state, no duplicate Maps</done>
</task>

<task type="auto">
  <name>Task 7: Integration test with curl</name>
  <files></files>
  <action>
Test the complete API flow with curl commands. Run the Next.js dev server and test:

```bash
cd /opt/agency-workspace/dashboard-daddy/dashboard

# Start dev server in background (or use existing Docker container)
npm run dev &
sleep 5

# Test 1: List agents
curl -s http://localhost:3000/api/agents | jq .

# Expected: List of agents with status "stopped"

# Test 2: Get single agent details
curl -s http://localhost:3000/api/agents/claude-code | jq .

# Expected: Agent details with status "stopped"

# Test 3: Start an agent (may fail if claude CLI not installed - that's OK)
curl -s -X POST http://localhost:3000/api/agents/claude-code/start \
  -H "Content-Type: application/json" \
  -d '{"workingDirectory": "/tmp"}' | jq .

# Expected: Either success with jobId, or error about command not found

# Test 4: Check status after start attempt
curl -s http://localhost:3000/api/agents/claude-code | jq .

# Expected: Status reflects actual state (running, error, or stopped)

# Test 5: Test SSE stream (run for 5 seconds then kill)
timeout 5 curl -N http://localhost:3000/api/agents/claude-code/stream || true

# Expected: SSE events with connection info and any buffered output

# Test 6: Stop the agent (if running)
curl -s -X POST http://localhost:3000/api/agents/claude-code/stop | jq .

# Cleanup
kill %1 2>/dev/null || true
```

Note: Full integration test may require claude/gemini/codex CLI tools to be installed in the Docker container. The key verification is that:
1. API routes respond without errors
2. Status changes are reflected across routes (shared state works)
3. SSE stream connects and sends events
  </action>
  <verify>
API routes return valid JSON responses
Status is consistent across GET /api/agents and GET /api/agents/[id]
SSE stream sends initial connection event
No 500 errors from module import issues
  </verify>
  <done>Integration tests pass, API is fully functional with ProcessManager</done>
</task>

</tasks>

<verification>
Plan 03-02 is complete when:
1. No API route files contain duplicate `agentStatusStore` Maps
2. All routes import from `@/lib/process-manager` and `@/lib/config-loader`
3. `POST /api/agents/[id]/start` calls real `spawnAgent`
4. `POST /api/agents/[id]/stop` calls real `stopAgent`
5. `GET /api/agents/[id]/stream` uses `subscribeToOutput` for real output
6. TypeScript compiles: `cd dashboard && npx tsc --noEmit`
7. curl tests show shared state across routes
</verification>

<success_criteria>
- Single source of truth: ProcessManager singleton
- No mock setTimeout delays in start/stop routes
- No fake generateAgentOutput in stream route
- Real child_process.spawn() executes CLI commands
- Real SIGTERM/SIGKILL terminates processes
- Real stdout/stderr streams to SSE clients
- Status consistent across all GET endpoints
</success_criteria>

<output>
After completion, create `.planning/phases/03-agent-api/03-02-SUMMARY.md` documenting:
- Files modified with before/after comparison
- curl test results
- Any issues with CLI tool availability
- Recommendations for Phase 4 (frontend integration)
</output>
