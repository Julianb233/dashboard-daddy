---
phase: 01-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - dashboard/Dockerfile
  - docker-compose.yml
autonomous: true

must_haves:
  truths:
    - "Dashboard service starts successfully in Docker"
    - "Dashboard accessible via Traefik at dashboard.dashboard-daddy.com"
    - "Hot reload works in development mode"
    - "Service coexists with existing vibe-kanban, terminal, and scim-bridge services"
  artifacts:
    - path: "dashboard/Dockerfile"
      provides: "Multi-stage Docker build for Next.js"
      contains: "FROM node"
    - path: "docker-compose.yml"
      provides: "Dashboard service definition with Traefik labels"
      contains: "dashboard:"
  key_links:
    - from: "docker-compose.yml"
      to: "dashboard/Dockerfile"
      via: "build context"
      pattern: "build:.*dashboard"
    - from: "docker-compose.yml"
      to: "Traefik"
      via: "labels"
      pattern: "traefik.http.routers.dashboard"
---

<objective>
Add Docker integration for the existing Next.js dashboard application.

Purpose: Complete Phase 1 by containerizing the dashboard and integrating it with the existing Docker Compose stack and Traefik routing.

Output: Dashboard running in Docker, accessible via `dashboard.dashboard-daddy.com` alongside existing services.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@docker-compose.yml
@dashboard/package.json
@dashboard/next.config.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Dockerfile for dashboard</name>
  <files>dashboard/Dockerfile</files>
  <action>
Create a multi-stage Dockerfile for the Next.js dashboard:

Stage 1 - Dependencies:
- Base: node:20-alpine
- Set WORKDIR /app
- Copy package.json and package-lock.json
- Run npm ci

Stage 2 - Builder:
- Copy source files
- Run npm run build
- Output: standalone build in .next/standalone

Stage 3 - Runner:
- Base: node:20-alpine (minimal)
- Set NODE_ENV=production
- Copy standalone output from builder
- Copy public/ and .next/static for assets
- Expose port 3000
- CMD: node server.js

Use Next.js standalone output mode - add to next.config.ts if not present:
```ts
output: 'standalone'
```

Why standalone: Produces minimal deployment, ~100MB vs ~500MB with node_modules.
  </action>
  <verify>
docker build -t dashboard-daddy-dashboard ./dashboard
Container builds without errors
  </verify>
  <done>Dockerfile exists and builds a working image</done>
</task>

<task type="auto">
  <name>Task 2: Add dashboard service to docker-compose.yml</name>
  <files>docker-compose.yml</files>
  <action>
Add dashboard service to docker-compose.yml with these specifications:

```yaml
  dashboard:
    build:
      context: ./dashboard
      dockerfile: Dockerfile
    restart: unless-stopped
    environment:
      - NODE_ENV=production
      - AUTH_SECRET=${AUTH_SECRET}
      - AUTH_TRUST_HOST=true
    networks:
      - root_default
      - web
    labels:
      - "traefik.enable=true"
      - "traefik.http.routers.dashboard.rule=Host(`dashboard.dashboard-daddy.com`)"
      - "traefik.http.routers.dashboard.entrypoints=websecure"
      - "traefik.http.routers.dashboard.tls=true"
      - "traefik.http.services.dashboard.loadbalancer.server.port=3000"
```

Key decisions:
- Use build context (not pre-built image) for easy iteration
- AUTH_SECRET needed for NextAuth session encryption
- AUTH_TRUST_HOST=true since Traefik handles TLS termination
- Same networks as other services (root_default, web)
- Port 3000 matches Next.js default

Do NOT remove or modify the existing vibe-kanban service - it stays on claude.dashboard-daddy.com for now.
  </action>
  <verify>
docker compose config (validates syntax)
docker compose up -d dashboard (starts service)
docker compose ps (shows dashboard running)
  </verify>
  <done>Dashboard service defined in compose, starts without errors</done>
</task>

<task type="auto">
  <name>Task 3: Test full integration</name>
  <files></files>
  <action>
Verify the complete integration works:

1. Ensure AUTH_SECRET is set in .env (generate if missing):
   ```bash
   # Check if AUTH_SECRET exists
   grep AUTH_SECRET .env || echo "AUTH_SECRET=$(openssl rand -base64 32)" >> .env
   ```

2. Build and start the dashboard service:
   ```bash
   docker compose build dashboard
   docker compose up -d dashboard
   ```

3. Check service health:
   ```bash
   docker compose ps dashboard
   docker compose logs dashboard --tail 50
   ```

4. Test local connectivity (from VPS):
   ```bash
   curl -s -o /dev/null -w "%{http_code}" http://localhost:3000 || echo "Use docker inspect to find IP"
   ```

5. Verify Traefik routing by checking labels are visible:
   ```bash
   docker inspect dashboard-daddy-dashboard-1 | grep -A5 traefik
   ```

If Cloudflare Tunnel is configured, the dashboard should be accessible at https://dashboard.dashboard-daddy.com.
  </action>
  <verify>
docker compose ps shows dashboard as "running" or "Up"
docker compose logs dashboard shows "Ready in" or similar Next.js startup message
No crash loops (restarts should be 0)
  </verify>
  <done>Dashboard service running in Docker, accessible via Traefik routing, coexisting with other services</done>
</task>

</tasks>

<verification>
Phase 1 is complete when:
1. `docker compose ps` shows dashboard service running
2. `docker compose logs dashboard` shows Next.js started successfully
3. Traefik labels are properly applied (visible in docker inspect)
4. Service restarts cleanly after `docker compose restart dashboard`
5. All other services (vibe-kanban, terminal, scim-bridge) remain functional
</verification>

<success_criteria>
- Dockerfile builds successfully (< 5 min build time)
- Dashboard service starts in < 30 seconds
- No port conflicts with existing services
- Service survives restart (restart: unless-stopped)
- Ready for Phase 2 (authentication layer)
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-01-SUMMARY.md` documenting:
- Final Dockerfile configuration
- docker-compose.yml changes
- Any environment variables added
- Verification results
</output>
